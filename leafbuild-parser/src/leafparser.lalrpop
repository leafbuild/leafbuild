use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

use leafbuild_ast::{
    ast::*,
    token_data::*,
    span::*,
};
use crate::{GrmError, lexer::{self, Tk, Token}};

grammar<'input, 'err>(
    input: &'input str,
    errors: &'err mut Vec<ErrorRecovery<usize, lexer::Token<'input>, GrmError>>,
);

SpannedNonterminal<Rule>: Spanned<Rule> = <start: @L> <rule: Rule> <end: @R> => Spanned::new(rule, Span::from((start, end)));
SL<Rule>: Span = <start: @L> <rule: Rule> <end: @R> => Span::from((start, end));
Box<Rule>: Box<Rule> = <rule: Rule> => Box::new(rule);

SingleComma: () = ",";

#[inline]
Delimitate<Rule, S>: Vec<Rule> =
    <mut rules: (<Rule> S)*> <last: Rule?>
        => {rules.extend(last); rules};

#[inline]
DelimitateNoTrailing<Rule, S>: Vec<Rule> =
    <first: Rule> <mut rules: ((S) <Rule>)*>
        => { rules.insert(0, first); rules };

#[inline]
Comma<Rule> = Delimitate<Rule, SingleComma>;

#[inline]
CommaNoTrailing<Rule> = DelimitateNoTrailing<Rule, SingleComma>;

JoinComma<A, B> = {
    <CommaNoTrailing<A>> (SingleComma) <CommaNoTrailing<B>> SingleComma?,
    <CommaNoTrailing<A>> SingleComma? => (<>, vec![]),
    <CommaNoTrailing<B>> SingleComma? => (vec![], <>),
    => (vec![], vec![]),
}

#[inline]
IdExpressionUnspanned: String = "identifier" => String::from(<>);

IdExpression = SpannedNonterminal<IdExpressionUnspanned>;

NumTok: NumVal =
    <start: @L> <num: "number"> <end: @R> =>?
        NumVal::from_str(num).map_err(|e| GrmError::from((e, Span::from((start, end)))).into());

Num = SpannedNonterminal<NumTok>;

#[inline]
BoolTok: bool = {
    "true" => true,
    "false" => false,
}

BoolLit = SpannedNonterminal<BoolTok>;

StrTok: String = {
    <s: "single line string"> => String::from(&s[1..(s.len()-1)]),
    <s: "multiline string"> => String::from(&s[3..(s.len()-3)]),
}

Str = SpannedNonterminal<StrTok>;

pub BuildDefinition = <LangItem*>;
Statement: Statement = {
    <ExecExprStatement> => Statement::ExecExpr(<>),
    <Assignment> => Statement::Assignment(<>),
    <Declaration> => Statement::Declaration(<>),
    <ConditionalStatement> => Statement::Conditional(<>),
    <ControlStatement> => Statement::Control(<>),
    <ForeachStatement> => Statement::Foreach(<>),
}

FnArgs: FnCallArgs =
    JoinComma<PositionalFnArg, NamedExpr>
        => FnCallArgs::from(<>);


PositionalFnArg: PositionalArg = Expr => PositionalArg::from(<>);

NamedExpr: NamedExpr = IdExpression SL<"="> Expr => NamedExpr::from((<>));

UnaryPlusMinusOpcode: UnaryOpcode = {
    SL<"-"> => UnaryOpcode::Minus(<>),
    SL<"+"> => UnaryOpcode::Plus(<>),
}

UnaryLogicalAndBitwiseNot: UnaryOpcode = {
    SL<"not"> => UnaryOpcode::Not(<>),
    SL<"~"> => UnaryOpcode::BitwiseNot(<>),
}

MulOp: Opcode = {
    SL<"*"> => Opcode::Mul(<>),
    SL<"/"> => Opcode::Div(<>),
    SL<"%"> => Opcode::Mod(<>),
}

AddOp: Opcode = {
    SL<"+"> => Opcode::Add(<>),
    SL<"-"> => Opcode::Sub(<>),
}

BitShiftOp: Opcode = {
    SL<"<<"> => Opcode::LBitshift(<>),
    SL<">>"> => Opcode::RBitshift(<>),
}

RelOp: Opcode = {
    SL<">"> => Opcode::G(<>),
    SL<"<"> => Opcode::L(<>),
    SL<">="> => Opcode::GE(<>),
    SL<"<="> => Opcode::LE(<>),
    SL<"in"> => Opcode::In(<>),
    SL<("not" "in")> => Opcode::NotIn(<>),
}

RelOp2: Opcode = {
    SL<"=="> => Opcode::Equal(<>),
    SL<"!="> => Opcode::NE(<>),
}

AndOp: Opcode = SL<"and"> => Opcode::And(<>);

OrOp: Opcode = SL<"or"> => Opcode::Or(<>);

ExecExprStatement: ExprStatement = {
    Expr SL<";"> => ExprStatement::from((<>)),
}

Expr: Expr = {
    #[precedence(level="0")]
    IdExpression => Expr::Atom(Atom::Id(<>)),
    #[precedence(level="0")]
    Num => Expr::Atom(Atom::Number(<>)),

    #[precedence(level="0")]
    Str => Expr::Atom(Atom::Str(<>)),

    #[precedence(level="0")]
    BoolLit=> Expr::Atom(Atom::Bool(<>)),

    #[precedence(level="0")]
    ArrayLit,

    #[precedence(level="0")]
    MapLit,

    #[precedence(level="1")]
    Box<Expr> SL<"("> FnArgs SL<")"> => Expr::FnCall(FnCall::new(<>)),

    #[precedence(level="1")]
    <base: Box<Expr>> <open_bracket: SL<"[">> <index: Box<Expr>> <close_bracket: SL<"]">> =>
            Expr::Indexed {base, left_bracket:open_bracket, index, right_bracket:close_bracket},

    // #[precedence(level="1")]
    // TODO: Property access

    #[precedence(level="2")]
    UnaryPlusMinusOpcode Box<Expr> => Expr::UnaryOp(<>),

    #[precedence(level="2")]
    UnaryLogicalAndBitwiseNot Box<Expr> => Expr::UnaryOp(<>),

    #[precedence(level="3")]
    #[assoc(side="left")]
    Box<Expr> MulOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="4")]
    #[assoc(side="left")]
    Box<Expr> AddOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="5")]
    #[assoc(side="left")]
    Box<Expr> BitShiftOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="6")]
    #[assoc(side="left")]
    Box<Expr> RelOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="7")]
    #[assoc(side="left")]
    Box<Expr> RelOp2 Box<Expr> => Expr::Op(<>),

    #[precedence(level="8")]
    #[assoc(side="left")]
    Box<Expr> AndOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="9")]
    #[assoc(side="left")]
    Box<Expr> OrOp Box<Expr> => Expr::Op(<>),

    #[precedence(level="10")]
    #[assoc(side="right")]
    <condition: Box<Expr>> <qmark: SL<"?">>
    <if_true: Box<Expr>> <colon: SL<":">> <if_false: Box<Expr>> =>
        Expr::Ternary{condition, qmark, if_true, colon, if_false},
};

//MemberAccessExpr: AstPropertyAccess = {
//    <t:Term> <dot: SpannedLocation<".">> <prop_name:IdExpression> => AstPropertyAccess::new(t, dot, prop_name),
//}
//
//MethodCall: AstMethodCall = {
//	<property_access:MemberAccess> "(" <args:FuncArgs> ")" <end: @R> => AstMethodCall::new(property_access, args, end),
//}

Declaration: Declaration = SL<"let"> IdExpression SL<"="> Expr SL<";"> => Declaration::from((<>));

Assignment: Assignment = Expr AtrOp Expr SL<";"> => Assignment::from((<>));

AtrOp: AtrOp = {
    SL<"="> => AtrOp::Atr(<>),
    SL<"+="> => AtrOp::AddAtr(<>),
    SL<"-="> => AtrOp::SubAtr(<>),
    SL<"*="> => AtrOp::MulAtr(<>),
    SL<"/="> => AtrOp::DivAtr(<>),
    SL<"%="> => AtrOp::ModAtr(<>),
}

ArrayLit: Expr =
    <left_brace: SL<"[">> <args: Comma<Expr>> <right_brace: SL<"]">> =>
        Expr::Atom(Atom::ArrayLit(left_brace, args, right_brace));

MapLit: Expr = SL<"{"> Comma<NamedExpr> SL<"}"> => Expr::Atom(Atom::MapLit(<>));

#[inline]
ConditionalStatement: ConditionalStatement = If ElseIf* Else? => ConditionalStatement::new(<>);

If: If = SL<"if"> Expr SL<"{"> Statement* SL<"}"> => If::new(<>);

ElseIf: ElseIf = SL<"else"> If => ElseIf::new(<>);

Else: Else = SL<"else"> SL<"{"> Statement* SL<"}"> => Else::new(<>);

ForeachStatement: ForeachStatement =
    SL<"foreach"> ForInExpr SL<"{"> Statement* SL<"}"> =>
        ForeachStatement::from((<>));

ForInExpr: ForInExpr =
    IdExpression SL<"in"> Expr => ForInExpr::new(<>);

ControlStatement: ControlStatement = {
    SL<"break"> SL<";"> => ControlStatement::Break(<>),
    SL<"continue"> SL<";"> => ControlStatement::Continue(<>),
    SL<"return"> Expr? SL<";"> => ControlStatement::Return(<>),
}

FnDecl: FnDecl = {
    SL<"fn"> IdExpression SL<"(">
        FnParams
    SL<")">
    FnBody => FnDecl::from((<>)),
}

FnParams = JoinComma<PositionalParam, DefaultParam>;

DefaultParam: DefaultParam = IdExpression SL<":"> TypeRef SL<"="> Expr => DefaultParam::from((<>));

PositionalParam: PositionalParam = IdExpression SL<":"> TypeRef => PositionalParam::from((<>));

TypeRef: TypeRef = {
    IdExpression=> TypeRef::from(<>),
}

FnBody: FnBody = {
    SL<"{"> Statement* Expr? SL<"}"> => FnBody::from((<>))
}

LangItem: LangItem = {
    FnDecl => LangItem::FnDecl(<>),
    Statement => LangItem::Statement(<>)
}

extern {
    type Location = usize;
    type Error = GrmError;

    enum lexer::Token<'input> {
        "+=" => Token {token: Tk::PlusEq, data: <&'input str>},
        "-=" => Token {token: Tk::MinusEq, data: <&'input str>},
        "*=" => Token {token: Tk::MulEq, data: <&'input str>},
        "/=" => Token {token: Tk::DivEq, data: <&'input str>},
        "%=" => Token {token: Tk::ModEq, data: <&'input str>},
        "+" => Token {token: Tk::Plus, data: <&'input str>},
        "-" => Token {token: Tk::Minus, data: <&'input str>},
        "*" => Token {token: Tk::Mul, data: <&'input str>},
        "/" => Token {token: Tk::Slash, data: <&'input str>},
        "%" => Token {token: Tk::Percent, data: <&'input str>},
        "==" => Token {token: Tk::EqualEqual, data: <&'input str>},
        ">=" => Token {token: Tk::GreaterEqual, data: <&'input str>},
        ">" => Token {token: Tk::GreaterThan, data: <&'input str>},
        "<=" => Token {token: Tk::LessEqual, data: <&'input str>},
        "<" => Token {token: Tk::LessThan, data: <&'input str>},
        "!=" => Token {token: Tk::NotEqual, data: <&'input str>},
        "=" => Token {token: Tk::Equal, data: <&'input str>},
        "<<" => Token {token: Tk::ShiftLeft, data: <&'input str>},
        ">>" => Token {token: Tk::ShiftRight, data: <&'input str>},
        "(" => Token {token: Tk::LParen, data: <&'input str>},
        "[" => Token {token: Tk::LBracket, data: <&'input str>},
        "{" => Token {token: Tk::LBrace, data: <&'input str>},
        ")" => Token {token: Tk::RParen, data: <&'input str>},
        "]" => Token {token: Tk::RBracket, data: <&'input str>},
        "}" => Token {token: Tk::RBrace, data: <&'input str>},
        "." => Token {token: Tk::Dot, data: <&'input str>},
        ":" => Token {token: Tk::Colon, data: <&'input str>},
        "?" => Token {token: Tk::QMark, data: <&'input str>},
        ";" => Token {token: Tk::Semicolon, data: <&'input str>},
        "," => Token {token: Tk::Comma, data: <&'input str>},
        "~" => Token {token: Tk::Tilda, data: <&'input str>},
        "and" => Token {token: Tk::And, data: <&'input str>},
        "or" => Token {token: Tk::Or, data: <&'input str>},
        "not" => Token {token: Tk::Not, data: <&'input str>},
        "in" => Token {token: Tk::In, data: <&'input str>},
        "let" => Token {token: Tk::Let, data: <&'input str>},
        "if" => Token {token: Tk::If, data: <&'input str>},
        "else" => Token {token: Tk::Else, data: <&'input str>},
        "foreach" => Token {token: Tk::ForEach, data: <&'input str>},
        "continue" => Token {token: Tk::Continue, data: <&'input str>},
        "break" => Token {token: Tk::Break, data: <&'input str>},
        "return" => Token {token: Tk::Return, data: <&'input str>},
        "true" => Token {token: Tk::True, data: <&'input str>},
        "false" => Token {token: Tk::False, data: <&'input str>},
        "fn" => Token {token: Tk::Fn, data: <&'input str>},
        "number" => Token {token: Tk::Number, data: <&'input str>},
        "identifier" => Token {token: Tk::Id, data: <&'input str>},
        "single line string" => Token {token: Tk::String, data: <&'input str>},
        "multiline string" => Token {token: Tk::MultilineString, data: <&'input str>},
    }
}

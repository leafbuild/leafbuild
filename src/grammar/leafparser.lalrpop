use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

use crate::{
	grammar::{
		lexer,
		lexer::*,
		ast::*,
	},
};

grammar<'input, 'err>(
    input: &'input str,
    errors: &'err mut Vec<ErrorRecovery<usize, lexer::Token<'input>, lexer::LexicalError>>,
);

SpannedNonterminal<Rule>: Spanned<Rule> = <start: @L> <rule: Rule> <end: @R> => Spanned::new(rule, Span::new(start, end));
SpannedLocation<Rule>: Span = <start: @L> <rule: Rule> <end: @R> => Span::new(start, end);

SingleComma: () = {
    "," => (),

    ! => errors.push(<>)
}

#[inline]
Comma<Rule>: Vec<Rule> =
    <mut rules: (<Rule> SingleComma)*> <last: Rule?> => {
        rules.extend(last);
        rules
    };

#[inline]
CommaNoTrailing<Rule>: Vec<Rule> = <first: Rule> <mut rules: (SingleComma <Rule>)*> => { rules.insert(0, first); rules };

IdExpressionUnspanned: String = "identifier" => String::from(<>);

IdExpression = SpannedNonterminal<IdExpressionUnspanned>;

NumTok: NumVal = "number" => NumVal::from_str(<>).unwrap();

Num = SpannedNonterminal<NumTok>;

BoolTok: bool = {
    "true" => true,
    "false" => false,
}

BoolLit = SpannedNonterminal<BoolTok>;

StrTok: String = {
    <s: r#"'(\\['nt\\]|[^'\\])+'"#> => String::from(&s[1..(s.len()-1)]),
    <s: r#"'''([^']*|[']{1,2}[^'])*'''"#> => String::from(&s[3..(s.len()-3)]),
}

Str = SpannedNonterminal<StrTok>;

UnaryNot: UnaryOpcode = SpannedLocation<"not"> => UnaryOpcode::Not(<>);

pub BuildDefinition = <Statement*>;
Statement: Statement = {
//    <MethodCall> ";" => AstStatement::MethodCall(call),
	<FuncCall> ";" => Statement::FuncCall(<>),
	<Assignment> ";" => Statement::Assignment(<>),
	<Declaration> ";" => Statement::Declaration(<>),
	<ConditionalStatement> => Statement::Conditional(<>),
	//<statement ControlStatement> => AstStatement::Control(statement),
	<RepetitiveStatement> => Statement::Repetitive(<>),
}

// function calls
FuncCall: FuncCall = IdExpression SpannedLocation<"("> FuncArgs SpannedLocation<")"> => FuncCall::new(<>);

FuncArgs: FuncCallArgs = {
	<pos: PositionalFuncArgs> SingleComma <named: NamedFuncArgs> SingleComma? => FuncCallArgs::new(<>),
	<PositionalFuncArgs> SingleComma? => FuncCallArgs::new_only_positional(<>),
	<NamedFuncArgs> SingleComma? => FuncCallArgs::new_only_named(<>),
	() => FuncCallArgs::empty(),
}

#[inline]
PositionalFuncArgs = CommaNoTrailing<PositionalFuncArg>;

PositionalFuncArg: PositionalArg = Expr => PositionalArg::from(<>);

#[inline]
NamedFuncArgs = CommaNoTrailing<NamedExpr>;

NamedExpr: NamedExpr = IdExpression SpannedLocation<"="> Expr => NamedExpr::from((<>));


IndexExpr: Box<Expr> = {
    <base: ExprAtom> <open_bracket: SpannedLocation<"[">> <index: Expr> <close_bracket: SpannedLocation<"]">> => Box::new(Expr::Indexed {base, open_bracket, index, close_bracket}),
}

ExprAtom: Box<Expr> = {
    FuncCall => Box::new(Expr::FuncCall(<>)),
    IndexExpr => <>,
    Num => Box::new(Expr::Atom(Atom::Number(<>))),
//    MethodCall,
}

UnaryPlusMinusOpcode: UnaryOpcode = {
	SpannedLocation<"-"> => UnaryOpcode::Minus(<>),
	SpannedLocation<"+"> => UnaryOpcode::Plus(<>),
}

UnaryPlusMinusExpression = {
    UnaryPlusMinusOpcode UnaryPlusMinusExpression => Box::new(Expr::UnaryOp(<>)),
    ExprAtom,
}

UnaryLogicalAndBitwiseNot: UnaryOpcode = {
	SpannedLocation<"not"> => UnaryOpcode::Not(<>),
	SpannedLocation<"~"> => UnaryOpcode::BitwiseNot(<>),
}

UnaryLogicalAndBitwiseNotExpression: Box<Expr> = {
    UnaryLogicalAndBitwiseNot UnaryPlusMinusExpression => Box::new(Expr::UnaryOp(<>)),
    UnaryPlusMinusExpression
}

MulOp: Opcode = {
    SpannedLocation<"*"> => Opcode::Mul(<>),
    SpannedLocation<"/"> => Opcode::Div(<>),
    SpannedLocation<"%"> => Opcode::Mod(<>),
}

Factor: Box<Expr> = {
    Factor MulOp UnaryLogicalAndBitwiseNotExpression => Box::new(Expr::Op(<>)),
    UnaryLogicalAndBitwiseNotExpression,
}

AddOp: Opcode = {
    SpannedLocation<"+"> => Opcode::Add(<>),
    SpannedLocation<"-"> => Opcode::Sub(<>),
}

AddExpr: Box<Expr> = {
    AddExpr AddOp Factor => Box::new(Expr::Op(<>)),
    Factor,
}

BitShiftOp: Opcode = {
    SpannedLocation<"<<"> => Opcode::LBitshift(<>),
    SpannedLocation<">>"> => Opcode::RBitshift(<>),
}

BitShiftExpr: Box<Expr> = {
    BitShiftExpr BitShiftOp AddExpr => Box::new(Expr::Op(<>)),
    AddExpr,
}

RelOp: Opcode = {
	SpannedLocation<">"> => Opcode::G(<>),
	SpannedLocation<"<"> => Opcode::L(<>),
	SpannedLocation<">="> => Opcode::GE(<>),
	SpannedLocation<"<="> => Opcode::LE(<>),
	SpannedLocation<"in"> => Opcode::In(<>),
	SpannedLocation<("not" "in")> => Opcode::NotIn(<>),
}

RelExpr: Box<Expr> = {
	RelExpr RelOp BitShiftExpr => Box::new(Expr::Op(<>)),
	AddExpr,
}

RelOp2: Opcode = {
    SpannedLocation<"=="> => Opcode::Equal(<>),
    SpannedLocation<"!="> => Opcode::NE(<>),
}

RelExpr2: Box<Expr> = {
	RelExpr2 RelOp2 RelExpr => Box::new(Expr::Op(<>)),
	RelExpr,
}

AndConditionalExpr: Box<Expr> = {
	AndConditionalExpr AndOp RelExpr2 => Box::new(Expr::Op(<>)),
	RelExpr2,
}

AndOp: Opcode = SpannedLocation<"and"> => Opcode::And(<>);

OrConditionalExpr: Box<Expr> = {
	OrConditionalExpr OrOp AndConditionalExpr => Box::new(Expr::Op(<>)),
	AndConditionalExpr,
}

OrOp: Opcode = SpannedLocation<"or"> => Opcode::Or(<>);

TernaryExpr: Box<Expr> = {
    <condition: OrConditionalExpr> <qmark: SpannedLocation<"?">> <if_true: TernaryExpr> <colon: SpannedLocation<":">> <if_false: OrConditionalExpr> =>
        Box::new(Expr::Ternary{condition, qmark, if_true, colon, if_false}),
    OrConditionalExpr
}

Expr = TernaryExpr;

//MemberAccessExpr: AstPropertyAccess = {
//    <t:Term> <dot: SpannedLocation<".">> <prop_name:IdExpression> => AstPropertyAccess::new(t, dot, prop_name),
//}
//
//MethodCall: AstMethodCall = {
//	<property_access:MemberAccess> "(" <args:FuncArgs> ")" <end: @R> => AstMethodCall::new(property_access, args, end),
//}

Declaration: Declaration =
	SpannedLocation<"let"> IdExpression SpannedLocation<"="> Expr =>
        Declaration::new(<>);

Assignment: Assignment =
	Expr AtrOp Expr =>
        Assignment::new(<>);

AtrOp: AtrOp = {
	SpannedLocation<"="> => AtrOp::Atr(<>),
	SpannedLocation<"+="> => AtrOp::AddAtr(<>),
	SpannedLocation<"-="> => AtrOp::SubAtr(<>),
	SpannedLocation<"*="> => AtrOp::MulAtr(<>),
	SpannedLocation<"/="> => AtrOp::DivAtr(<>),
	SpannedLocation<"%="> => AtrOp::ModAtr(<>),
}

ArrayLit: Box<Expr> =
	<left_brace: SpannedLocation<"{">> <args: Comma<Expr>> <right_brace: SpannedLocation<"}">> =>
        Box::new(Expr::Atom(Atom::ArrayLit(left_brace, args.into_iter().map(|x| *x).collect(), right_brace)));

MapLit: Box<Expr> =
	SpannedLocation<"{"> Comma<NamedExpr> SpannedLocation<"}"> =>
        Box::new(Expr::Atom(Atom::MapLit(<>)));


#[inline]
ConditionalStatement: ConditionalStatement =
	If ElseIf* Else? =>
        ConditionalStatement::new(<>);

If: If =
	SpannedLocation<"if"> Expr SpannedLocation<"{"> Statement* SpannedLocation<"}"> =>
        If::new(<>);

ElseIf: ElseIf =
	SpannedLocation<"else"> If =>
        ElseIf::new(<>);

Else: Else =
	SpannedLocation<"else"> SpannedLocation<"{"> Statement+ SpannedLocation<"}"> =>
        Else::new(<>);

RepetitiveStatement: RepetitiveStatement =
    SpannedLocation<"foreach"> ForInExpr SpannedLocation<"{"> Statement* SpannedLocation<"}"> =>
        RepetitiveStatement::new(<>);

ForInExpr: ForInExpr =
    IdExpression SpannedLocation<"in"> Expr => ForInExpr::new(<>);

ControlStatement: ControlStatement = {
	SpannedLocation<"break"> => ControlStatement::Break(<>),
	SpannedLocation<"continue"> => ControlStatement::Continue(<>),
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "+=" => Token {token: Tk::PlusEq, data: <&'input str>},
        "-=" => Token {token: Tk::MinusEq, data: <&'input str>},
        "*=" => Token {token: Tk::MulEq, data: <&'input str>},
        "/=" => Token {token: Tk::DivEq, data: <&'input str>},
        "%=" => Token {token: Tk::ModEq, data: <&'input str>},
        "+" => Token {token: Tk::Plus, data: <&'input str>},
        "-" => Token {token: Tk::Minus, data: <&'input str>},
        "*" => Token {token: Tk::Mul, data: <&'input str>},
        "/" => Token {token: Tk::Slash, data: <&'input str>},
        "%" => Token {token: Tk::Percent, data: <&'input str>},
        "==" => Token {token: Tk::EqualEqual, data: <&'input str>},
        ">=" => Token {token: Tk::GreaterEqual, data: <&'input str>},
        ">" => Token {token: Tk::GreaterThan, data: <&'input str>},
        "<=" => Token {token: Tk::LessEqual, data: <&'input str>},
        "<" => Token {token: Tk::LessThan, data: <&'input str>},
        "!=" => Token {token: Tk::NotEqual, data: <&'input str>},
        "=" => Token {token: Tk::Equal, data: <&'input str>},
        "<<" => Token {token: Tk::ShiftLeft, data: <&'input str>},
        ">>" => Token {token: Tk::ShiftRight, data: <&'input str>},
        "(" => Token {token: Tk::LParen, data: <&'input str>},
        "[" => Token {token: Tk::LBracket, data: <&'input str>},
        "{" => Token {token: Tk::LBrace, data: <&'input str>},
        ")" => Token {token: Tk::RParen, data: <&'input str>},
        "]" => Token {token: Tk::RBracket, data: <&'input str>},
        "}" => Token {token: Tk::RBrace, data: <&'input str>},
        "." => Token {token: Tk::Dot, data: <&'input str>},
        ":" => Token {token: Tk::Colon, data: <&'input str>},
        "?" => Token {token: Tk::QMark, data: <&'input str>},
        ";" => Token {token: Tk::Semicolon, data: <&'input str>},
        "," => Token {token: Tk::Comma, data: <&'input str>},
        "~" => Token {token: Tk::Tilda, data: <&'input str>},
        "and" => Token {token: Tk::And, data: <&'input str>},
        "or" => Token {token: Tk::Or, data: <&'input str>},
        "not" => Token {token: Tk::Not, data: <&'input str>},
        "in" => Token {token: Tk::In, data: <&'input str>},
        "let" => Token {token: Tk::Let, data: <&'input str>},
        "if" => Token {token: Tk::If, data: <&'input str>},
        "else" => Token {token: Tk::Else, data: <&'input str>},
        "foreach" => Token {token: Tk::ForEach, data: <&'input str>},
        "continue" => Token {token: Tk::Continue, data: <&'input str>},
        "break" => Token {token: Tk::Break, data: <&'input str>},
        "true" => Token {token: Tk::True, data: <&'input str>},
        "false" => Token {token: Tk::False, data: <&'input str>},
        "number" => Token {token: Tk::Number, data: <&'input str>},
        "identifier" => Token {token: Tk::Id, data: <&'input str>},
        r#"'(\\['nt\\]|[^'\\])+'"# => Token {token: Tk::String, data: <&'input str>},
        r#"'''([^']*|[']{1,2}[^'])*'''"# => Token {token: Tk::MultilineString, data: <&'input str>},
    }
}

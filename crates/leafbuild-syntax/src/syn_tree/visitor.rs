// @generated by xtask generate-grammar
use super::{
    implementation::*, AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,
};
#[allow(unused_variables)]
#[doc = "The visitor trait"]
pub trait Visitor {
    #[doc = "The result of visit methods"]
    type Output;
    #[doc = r"
            Behavior if a visitor method wasn't overridden.
            It's given the name of the method if, known at compile time.
            "]
    fn undefined(&mut self, name: &'static str) -> Self::Output {
        panic!("Visitor doesn't implement {}", name)
    }
    #[doc = "Visits a Id token"]
    fn visit_id(&mut self, id: Id) -> Self::Output {
        self.undefined("visit_id")
    }
    #[doc = "Visits a NumLit token"]
    fn visit_num_lit(&mut self, num_lit: NumLit) -> Self::Output {
        self.undefined("visit_num_lit")
    }
    #[doc = "Visits a Str token"]
    fn visit_str(&mut self, str: Str) -> Self::Output {
        self.undefined("visit_str")
    }
    #[doc = "Visits a MultilineStr token"]
    fn visit_multiline_str(&mut self, multiline_str: MultilineStr) -> Self::Output {
        self.undefined("visit_multiline_str")
    }
    #[doc = "Visits a SingleLineComment token"]
    fn visit_single_line_comment(
        &mut self,
        single_line_comment: SingleLineComment,
    ) -> Self::Output {
        self.undefined("visit_single_line_comment")
    }
    #[doc = "Visits a BlockComment token"]
    fn visit_block_comment(&mut self, block_comment: BlockComment) -> Self::Output {
        self.undefined("visit_block_comment")
    }
    #[doc = "Visits a Whitespace token"]
    fn visit_whitespace(&mut self, whitespace: Whitespace) -> Self::Output {
        self.undefined("visit_whitespace")
    }
    #[doc = "Visits a PlusEq token"]
    fn visit_plus_eq(&mut self, plus_eq: PlusEq) -> Self::Output {
        self.undefined("visit_plus_eq")
    }
    #[doc = "Visits a MinusEq token"]
    fn visit_minus_eq(&mut self, minus_eq: MinusEq) -> Self::Output {
        self.undefined("visit_minus_eq")
    }
    #[doc = "Visits a MulEq token"]
    fn visit_mul_eq(&mut self, mul_eq: MulEq) -> Self::Output {
        self.undefined("visit_mul_eq")
    }
    #[doc = "Visits a DivEq token"]
    fn visit_div_eq(&mut self, div_eq: DivEq) -> Self::Output {
        self.undefined("visit_div_eq")
    }
    #[doc = "Visits a ModEq token"]
    fn visit_mod_eq(&mut self, mod_eq: ModEq) -> Self::Output {
        self.undefined("visit_mod_eq")
    }
    #[doc = "Visits a Plus token"]
    fn visit_plus(&mut self, plus: Plus) -> Self::Output {
        self.undefined("visit_plus")
    }
    #[doc = "Visits a Minus token"]
    fn visit_minus(&mut self, minus: Minus) -> Self::Output {
        self.undefined("visit_minus")
    }
    #[doc = "Visits a Asterisk token"]
    fn visit_asterisk(&mut self, asterisk: Asterisk) -> Self::Output {
        self.undefined("visit_asterisk")
    }
    #[doc = "Visits a Slash token"]
    fn visit_slash(&mut self, slash: Slash) -> Self::Output {
        self.undefined("visit_slash")
    }
    #[doc = "Visits a Percent token"]
    fn visit_percent(&mut self, percent: Percent) -> Self::Output {
        self.undefined("visit_percent")
    }
    #[doc = "Visits a EqEq token"]
    fn visit_eq_eq(&mut self, eq_eq: EqEq) -> Self::Output {
        self.undefined("visit_eq_eq")
    }
    #[doc = "Visits a GreaterEq token"]
    fn visit_greater_eq(&mut self, greater_eq: GreaterEq) -> Self::Output {
        self.undefined("visit_greater_eq")
    }
    #[doc = "Visits a Greater token"]
    fn visit_greater(&mut self, greater: Greater) -> Self::Output {
        self.undefined("visit_greater")
    }
    #[doc = "Visits a LessEq token"]
    fn visit_less_eq(&mut self, less_eq: LessEq) -> Self::Output {
        self.undefined("visit_less_eq")
    }
    #[doc = "Visits a Less token"]
    fn visit_less(&mut self, less: Less) -> Self::Output {
        self.undefined("visit_less")
    }
    #[doc = "Visits a Eq token"]
    fn visit_eq(&mut self, eq: Eq) -> Self::Output {
        self.undefined("visit_eq")
    }
    #[doc = "Visits a NotEq token"]
    fn visit_not_eq(&mut self, not_eq: NotEq) -> Self::Output {
        self.undefined("visit_not_eq")
    }
    #[doc = "Visits a LParen token"]
    fn visit_lparen(&mut self, lparen: LParen) -> Self::Output {
        self.undefined("visit_lparen")
    }
    #[doc = "Visits a RParen token"]
    fn visit_rparen(&mut self, rparen: RParen) -> Self::Output {
        self.undefined("visit_rparen")
    }
    #[doc = "Visits a LBracket token"]
    fn visit_lbracket(&mut self, lbracket: LBracket) -> Self::Output {
        self.undefined("visit_lbracket")
    }
    #[doc = "Visits a RBracket token"]
    fn visit_rbracket(&mut self, rbracket: RBracket) -> Self::Output {
        self.undefined("visit_rbracket")
    }
    #[doc = "Visits a LBrace token"]
    fn visit_lbrace(&mut self, lbrace: LBrace) -> Self::Output {
        self.undefined("visit_lbrace")
    }
    #[doc = "Visits a RBrace token"]
    fn visit_rbrace(&mut self, rbrace: RBrace) -> Self::Output {
        self.undefined("visit_rbrace")
    }
    #[doc = "Visits a Dot token"]
    fn visit_dot(&mut self, dot: Dot) -> Self::Output {
        self.undefined("visit_dot")
    }
    #[doc = "Visits a Colon token"]
    fn visit_colon(&mut self, colon: Colon) -> Self::Output {
        self.undefined("visit_colon")
    }
    #[doc = "Visits a QMark token"]
    fn visit_qmark(&mut self, qmark: QMark) -> Self::Output {
        self.undefined("visit_qmark")
    }
    #[doc = "Visits a Semicolon token"]
    fn visit_semicolon(&mut self, semicolon: Semicolon) -> Self::Output {
        self.undefined("visit_semicolon")
    }
    #[doc = "Visits a Comma token"]
    fn visit_comma(&mut self, comma: Comma) -> Self::Output {
        self.undefined("visit_comma")
    }
    #[doc = "Visits a AndKw token"]
    fn visit_and_kw(&mut self, and_kw: AndKw) -> Self::Output {
        self.undefined("visit_and_kw")
    }
    #[doc = "Visits a OrKw token"]
    fn visit_or_kw(&mut self, or_kw: OrKw) -> Self::Output {
        self.undefined("visit_or_kw")
    }
    #[doc = "Visits a NotKw token"]
    fn visit_not_kw(&mut self, not_kw: NotKw) -> Self::Output {
        self.undefined("visit_not_kw")
    }
    #[doc = "Visits a InKw token"]
    fn visit_in_kw(&mut self, in_kw: InKw) -> Self::Output {
        self.undefined("visit_in_kw")
    }
    #[doc = "Visits a LetKw token"]
    fn visit_let_kw(&mut self, let_kw: LetKw) -> Self::Output {
        self.undefined("visit_let_kw")
    }
    #[doc = "Visits a IfKw token"]
    fn visit_if_kw(&mut self, if_kw: IfKw) -> Self::Output {
        self.undefined("visit_if_kw")
    }
    #[doc = "Visits a ElseKw token"]
    fn visit_else_kw(&mut self, else_kw: ElseKw) -> Self::Output {
        self.undefined("visit_else_kw")
    }
    #[doc = "Visits a ForeachKw token"]
    fn visit_foreach_kw(&mut self, foreach_kw: ForeachKw) -> Self::Output {
        self.undefined("visit_foreach_kw")
    }
    #[doc = "Visits a ContinueKw token"]
    fn visit_continue_kw(&mut self, continue_kw: ContinueKw) -> Self::Output {
        self.undefined("visit_continue_kw")
    }
    #[doc = "Visits a BreakKw token"]
    fn visit_break_kw(&mut self, break_kw: BreakKw) -> Self::Output {
        self.undefined("visit_break_kw")
    }
    #[doc = "Visits a ReturnKw token"]
    fn visit_return_kw(&mut self, return_kw: ReturnKw) -> Self::Output {
        self.undefined("visit_return_kw")
    }
    #[doc = "Visits a TrueKw token"]
    fn visit_true_kw(&mut self, true_kw: TrueKw) -> Self::Output {
        self.undefined("visit_true_kw")
    }
    #[doc = "Visits a FalseKw token"]
    fn visit_false_kw(&mut self, false_kw: FalseKw) -> Self::Output {
        self.undefined("visit_false_kw")
    }
    #[doc = "Visits a FnKw token"]
    fn visit_fn_kw(&mut self, fn_kw: FnKw) -> Self::Output {
        self.undefined("visit_fn_kw")
    }
    #[doc = "Visits a StructKw token"]
    fn visit_struct_kw(&mut self, struct_kw: StructKw) -> Self::Output {
        self.undefined("visit_struct_kw")
    }
    #[doc = "Visits a Newline token"]
    fn visit_newline(&mut self, newline: Newline) -> Self::Output {
        self.undefined("visit_newline")
    }
    #[doc = "Visits a Expr node"]
    fn visit_expr(&mut self, expr: Expr) -> Self::Output {
        self.undefined("visit_expr")
    }
    #[doc = "Visits a ExprBlock node"]
    fn visit_expr_block(&mut self, expr_block: ExprBlock) -> Self::Output {
        self.undefined("visit_expr_block")
    }
    #[doc = "Visits a KExpr node"]
    fn visit_kexpr(&mut self, kexpr: KExpr) -> Self::Output {
        self.undefined("visit_kexpr")
    }
    #[doc = "Visits a ArrayLitExpr node"]
    fn visit_array_lit_expr(&mut self, array_lit_expr: ArrayLitExpr) -> Self::Output {
        self.undefined("visit_array_lit_expr")
    }
    #[doc = "Visits a MapLitExpr node"]
    fn visit_map_lit_expr(&mut self, map_lit_expr: MapLitExpr) -> Self::Output {
        self.undefined("visit_map_lit_expr")
    }
    #[doc = "Visits a StrLit node"]
    fn visit_str_lit(&mut self, str_lit: StrLit) -> Self::Output {
        self.undefined("visit_str_lit")
    }
    #[doc = "Visits a PrimaryExpr node"]
    fn visit_primary_expr(&mut self, primary_expr: PrimaryExpr) -> Self::Output {
        self.undefined("visit_primary_expr")
    }
    #[doc = "Visits a PrefixUnaryOpExpr node"]
    fn visit_prefix_unary_op_expr(
        &mut self,
        prefix_unary_op_expr: PrefixUnaryOpExpr,
    ) -> Self::Output {
        self.undefined("visit_prefix_unary_op_expr")
    }
    #[doc = "Visits a InfixBinaryOpExpr node"]
    fn visit_infix_binary_op_expr(
        &mut self,
        infix_binary_op_expr: InfixBinaryOpExpr,
    ) -> Self::Output {
        self.undefined("visit_infix_binary_op_expr")
    }
    #[doc = "Visits a FnCallExpr node"]
    fn visit_fn_call_expr(&mut self, fn_call_expr: FnCallExpr) -> Self::Output {
        self.undefined("visit_fn_call_expr")
    }
    #[doc = "Visits a FnCallArgsList node"]
    fn visit_fn_call_args_list(&mut self, fn_call_args_list: FnCallArgsList) -> Self::Output {
        self.undefined("visit_fn_call_args_list")
    }
    #[doc = "Visits a FArg node"]
    fn visit_farg(&mut self, farg: FArg) -> Self::Output {
        self.undefined("visit_farg")
    }
    #[doc = "Visits a TupleExpr node"]
    fn visit_tuple_expr(&mut self, tuple_expr: TupleExpr) -> Self::Output {
        self.undefined("visit_tuple_expr")
    }
    #[doc = "Visits a BoolLit node"]
    fn visit_bool_lit(&mut self, bool_lit: BoolLit) -> Self::Output {
        self.undefined("visit_bool_lit")
    }
    #[doc = "Visits a IndexExpr node"]
    fn visit_index_expr(&mut self, index_expr: IndexExpr) -> Self::Output {
        self.undefined("visit_index_expr")
    }
    #[doc = "Visits a IndexExprBrackets node"]
    fn visit_index_expr_brackets(
        &mut self,
        index_expr_brackets: IndexExprBrackets,
    ) -> Self::Output {
        self.undefined("visit_index_expr_brackets")
    }
    #[doc = "Visits a Assignment node"]
    fn visit_assignment(&mut self, assignment: Assignment) -> Self::Output {
        self.undefined("visit_assignment")
    }
    #[doc = "Visits a Declaration node"]
    fn visit_declaration(&mut self, declaration: Declaration) -> Self::Output {
        self.undefined("visit_declaration")
    }
    #[doc = "Visits a Conditional node"]
    fn visit_conditional(&mut self, conditional: Conditional) -> Self::Output {
        self.undefined("visit_conditional")
    }
    #[doc = "Visits a Foreach node"]
    fn visit_foreach(&mut self, foreach: Foreach) -> Self::Output {
        self.undefined("visit_foreach")
    }
    #[doc = "Visits a ForInExpr node"]
    fn visit_for_in_expr(&mut self, for_in_expr: ForInExpr) -> Self::Output {
        self.undefined("visit_for_in_expr")
    }
    #[doc = "Visits a ControlStatement node"]
    fn visit_control_statement(&mut self, control_statement: ControlStatement) -> Self::Output {
        self.undefined("visit_control_statement")
    }
    #[doc = "Visits a ExprStatement node"]
    fn visit_expr_statement(&mut self, expr_statement: ExprStatement) -> Self::Output {
        self.undefined("visit_expr_statement")
    }
    #[doc = "Visits a Tuple node"]
    fn visit_tuple(&mut self, tuple: Tuple) -> Self::Output {
        self.undefined("visit_tuple")
    }
    #[doc = "Visits a ConditionalBranch node"]
    fn visit_conditional_branch(&mut self, conditional_branch: ConditionalBranch) -> Self::Output {
        self.undefined("visit_conditional_branch")
    }
    #[doc = "Visits a Statement node"]
    fn visit_statement(&mut self, statement: Statement) -> Self::Output {
        self.undefined("visit_statement")
    }
    #[doc = "Visits a StructDecl node"]
    fn visit_struct_decl(&mut self, struct_decl: StructDecl) -> Self::Output {
        self.undefined("visit_struct_decl")
    }
    #[doc = "Visits a StructFieldList node"]
    fn visit_struct_field_list(&mut self, struct_field_list: StructFieldList) -> Self::Output {
        self.undefined("visit_struct_field_list")
    }
    #[doc = "Visits a StructField node"]
    fn visit_struct_field(&mut self, struct_field: StructField) -> Self::Output {
        self.undefined("visit_struct_field")
    }
    #[doc = "Visits a TypeRef node"]
    fn visit_type_ref(&mut self, type_ref: TypeRef) -> Self::Output {
        self.undefined("visit_type_ref")
    }
    #[doc = "Visits a TypeRefGenerics node"]
    fn visit_type_ref_generics(&mut self, type_ref_generics: TypeRefGenerics) -> Self::Output {
        self.undefined("visit_type_ref_generics")
    }
    #[doc = "Visits a LangItem node"]
    fn visit_lang_item(&mut self, lang_item: LangItem) -> Self::Output {
        self.undefined("visit_lang_item")
    }
    #[doc = "Visits a Root node"]
    fn visit_root(&mut self, root: Root) -> Self::Output {
        self.undefined("visit_root")
    }
    #[allow(unsafe_code)]
    #[doc = "Visits the node"]
    fn visit(&mut self, node: SyntaxNode) -> Self::Output {
        match node.kind() {
            SyntaxKind::Expr => self.visit_expr(unsafe { Expr::new(node) }),
            SyntaxKind::ExprBlock => self.visit_expr_block(unsafe { ExprBlock::new(node) }),
            SyntaxKind::KExpr => self.visit_kexpr(unsafe { KExpr::new(node) }),
            SyntaxKind::ArrayLitExpr => {
                self.visit_array_lit_expr(unsafe { ArrayLitExpr::new(node) })
            }
            SyntaxKind::MapLitExpr => self.visit_map_lit_expr(unsafe { MapLitExpr::new(node) }),
            SyntaxKind::StrLit => self.visit_str_lit(unsafe { StrLit::new(node) }),
            SyntaxKind::PrimaryExpr => self.visit_primary_expr(unsafe { PrimaryExpr::new(node) }),
            SyntaxKind::PrefixUnaryOpExpr => {
                self.visit_prefix_unary_op_expr(unsafe { PrefixUnaryOpExpr::new(node) })
            }
            SyntaxKind::InfixBinOpExpr => {
                self.visit_infix_binary_op_expr(unsafe { InfixBinaryOpExpr::new(node) })
            }
            SyntaxKind::FnCallExpr => self.visit_fn_call_expr(unsafe { FnCallExpr::new(node) }),
            SyntaxKind::FnCallArgsList => {
                self.visit_fn_call_args_list(unsafe { FnCallArgsList::new(node) })
            }
            SyntaxKind::FArg => self.visit_farg(unsafe { FArg::new(node) }),
            SyntaxKind::TupleExpr => self.visit_tuple_expr(unsafe { TupleExpr::new(node) }),
            SyntaxKind::BoolLit => self.visit_bool_lit(unsafe { BoolLit::new(node) }),
            SyntaxKind::IndexExpr => self.visit_index_expr(unsafe { IndexExpr::new(node) }),
            SyntaxKind::IndexExprBrackets => {
                self.visit_index_expr_brackets(unsafe { IndexExprBrackets::new(node) })
            }
            SyntaxKind::Assignment => self.visit_assignment(unsafe { Assignment::new(node) }),
            SyntaxKind::Declaration => self.visit_declaration(unsafe { Declaration::new(node) }),
            SyntaxKind::Conditional => self.visit_conditional(unsafe { Conditional::new(node) }),
            SyntaxKind::Foreach => self.visit_foreach(unsafe { Foreach::new(node) }),
            SyntaxKind::ForInExpr => self.visit_for_in_expr(unsafe { ForInExpr::new(node) }),
            SyntaxKind::ControlStatement => {
                self.visit_control_statement(unsafe { ControlStatement::new(node) })
            }
            SyntaxKind::ExprStatement => {
                self.visit_expr_statement(unsafe { ExprStatement::new(node) })
            }
            SyntaxKind::Tuple => self.visit_tuple(unsafe { Tuple::new(node) }),
            SyntaxKind::ConditionalBranch => {
                self.visit_conditional_branch(unsafe { ConditionalBranch::new(node) })
            }
            SyntaxKind::Statement => self.visit_statement(unsafe { Statement::new(node) }),
            SyntaxKind::StructDecl => self.visit_struct_decl(unsafe { StructDecl::new(node) }),
            SyntaxKind::StructFieldList => {
                self.visit_struct_field_list(unsafe { StructFieldList::new(node) })
            }
            SyntaxKind::StructField => self.visit_struct_field(unsafe { StructField::new(node) }),
            SyntaxKind::TypeRef => self.visit_type_ref(unsafe { TypeRef::new(node) }),
            SyntaxKind::TypeRefGenerics => {
                self.visit_type_ref_generics(unsafe { TypeRefGenerics::new(node) })
            }
            SyntaxKind::LangItem => self.visit_lang_item(unsafe { LangItem::new(node) }),
            SyntaxKind::ROOT => self.visit_root(unsafe { Root::new(node) }),
            _ => unreachable!(),
        }
    }
    #[allow(unsafe_code)]
    #[doc = "Visits the token"]
    fn visit_token(&mut self, token: SyntaxToken) -> Self::Output {
        match token.kind() {
            SyntaxKind::ID => self.visit_id(unsafe { Id::new(token) }),
            SyntaxKind::NUM => self.visit_num_lit(unsafe { NumLit::new(token) }),
            SyntaxKind::STRING => self.visit_str(unsafe { Str::new(token) }),
            SyntaxKind::MULTILINE_STRING => {
                self.visit_multiline_str(unsafe { MultilineStr::new(token) })
            }
            SyntaxKind::SINGLE_LINE_COMMENT => {
                self.visit_single_line_comment(unsafe { SingleLineComment::new(token) })
            }
            SyntaxKind::BLOCK_COMMENT => {
                self.visit_block_comment(unsafe { BlockComment::new(token) })
            }
            SyntaxKind::WHITESPACE => self.visit_whitespace(unsafe { Whitespace::new(token) }),
            SyntaxKind::PLUS_EQ => self.visit_plus_eq(unsafe { PlusEq::new(token) }),
            SyntaxKind::MINUS_EQ => self.visit_minus_eq(unsafe { MinusEq::new(token) }),
            SyntaxKind::MUL_EQ => self.visit_mul_eq(unsafe { MulEq::new(token) }),
            SyntaxKind::DIV_EQ => self.visit_div_eq(unsafe { DivEq::new(token) }),
            SyntaxKind::MOD_EQ => self.visit_mod_eq(unsafe { ModEq::new(token) }),
            SyntaxKind::PLUS => self.visit_plus(unsafe { Plus::new(token) }),
            SyntaxKind::MINUS => self.visit_minus(unsafe { Minus::new(token) }),
            SyntaxKind::ASTERISK => self.visit_asterisk(unsafe { Asterisk::new(token) }),
            SyntaxKind::SLASH => self.visit_slash(unsafe { Slash::new(token) }),
            SyntaxKind::PERCENT => self.visit_percent(unsafe { Percent::new(token) }),
            SyntaxKind::EQ_EQ => self.visit_eq_eq(unsafe { EqEq::new(token) }),
            SyntaxKind::GREATER_EQ => self.visit_greater_eq(unsafe { GreaterEq::new(token) }),
            SyntaxKind::GREATER => self.visit_greater(unsafe { Greater::new(token) }),
            SyntaxKind::LESS_EQ => self.visit_less_eq(unsafe { LessEq::new(token) }),
            SyntaxKind::LESS => self.visit_less(unsafe { Less::new(token) }),
            SyntaxKind::EQ => self.visit_eq(unsafe { Eq::new(token) }),
            SyntaxKind::NEQ => self.visit_not_eq(unsafe { NotEq::new(token) }),
            SyntaxKind::L_PAREN => self.visit_lparen(unsafe { LParen::new(token) }),
            SyntaxKind::R_PAREN => self.visit_rparen(unsafe { RParen::new(token) }),
            SyntaxKind::L_BRACKET => self.visit_lbracket(unsafe { LBracket::new(token) }),
            SyntaxKind::R_BRACKET => self.visit_rbracket(unsafe { RBracket::new(token) }),
            SyntaxKind::L_BRACE => self.visit_lbrace(unsafe { LBrace::new(token) }),
            SyntaxKind::R_BRACE => self.visit_rbrace(unsafe { RBrace::new(token) }),
            SyntaxKind::DOT => self.visit_dot(unsafe { Dot::new(token) }),
            SyntaxKind::COLON => self.visit_colon(unsafe { Colon::new(token) }),
            SyntaxKind::QMARK => self.visit_qmark(unsafe { QMark::new(token) }),
            SyntaxKind::SEMICOLON => self.visit_semicolon(unsafe { Semicolon::new(token) }),
            SyntaxKind::COMMA => self.visit_comma(unsafe { Comma::new(token) }),
            SyntaxKind::AND_KW => self.visit_and_kw(unsafe { AndKw::new(token) }),
            SyntaxKind::OR_KW => self.visit_or_kw(unsafe { OrKw::new(token) }),
            SyntaxKind::NOT_KW => self.visit_not_kw(unsafe { NotKw::new(token) }),
            SyntaxKind::IN_KW => self.visit_in_kw(unsafe { InKw::new(token) }),
            SyntaxKind::LET_KW => self.visit_let_kw(unsafe { LetKw::new(token) }),
            SyntaxKind::IF_KW => self.visit_if_kw(unsafe { IfKw::new(token) }),
            SyntaxKind::ELSE_KW => self.visit_else_kw(unsafe { ElseKw::new(token) }),
            SyntaxKind::FOREACH_KW => self.visit_foreach_kw(unsafe { ForeachKw::new(token) }),
            SyntaxKind::CONTINUE_KW => self.visit_continue_kw(unsafe { ContinueKw::new(token) }),
            SyntaxKind::BREAK_KW => self.visit_break_kw(unsafe { BreakKw::new(token) }),
            SyntaxKind::RETURN_KW => self.visit_return_kw(unsafe { ReturnKw::new(token) }),
            SyntaxKind::TRUE_KW => self.visit_true_kw(unsafe { TrueKw::new(token) }),
            SyntaxKind::FALSE_KW => self.visit_false_kw(unsafe { FalseKw::new(token) }),
            SyntaxKind::FN_KW => self.visit_fn_kw(unsafe { FnKw::new(token) }),
            SyntaxKind::STRUCT_KW => self.visit_struct_kw(unsafe { StructKw::new(token) }),
            SyntaxKind::NEWLINE => self.visit_newline(unsafe { Newline::new(token) }),
            _ => unreachable!(),
        }
    }
    #[allow(unsafe_code)]
    #[doc = "Visits the element"]
    fn visit_element(&mut self, element: SyntaxElement) -> Self::Output {
        match element {
            SyntaxElement::Node(node) => self.visit(node),
            SyntaxElement::Token(token) => self.visit_token(token),
        }
    }
}

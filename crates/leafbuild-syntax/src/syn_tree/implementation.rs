// @generated by xtask generate-grammar
#![allow(missing_docs)]
use super::{AstNode, AstToken, SyntaxKind, SyntaxNode, SyntaxToken};
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct PlusEq {
    syntax: SyntaxToken,
}
impl AstToken for PlusEq {
    const KIND: SyntaxKind = SyntaxKind::PLUS_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct MinusEq {
    syntax: SyntaxToken,
}
impl AstToken for MinusEq {
    const KIND: SyntaxKind = SyntaxKind::MINUS_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct MulEq {
    syntax: SyntaxToken,
}
impl AstToken for MulEq {
    const KIND: SyntaxKind = SyntaxKind::MUL_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct DivEq {
    syntax: SyntaxToken,
}
impl AstToken for DivEq {
    const KIND: SyntaxKind = SyntaxKind::DIV_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct ModEq {
    syntax: SyntaxToken,
}
impl AstToken for ModEq {
    const KIND: SyntaxKind = SyntaxKind::MOD_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Plus {
    syntax: SyntaxToken,
}
impl AstToken for Plus {
    const KIND: SyntaxKind = SyntaxKind::PLUS;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Minus {
    syntax: SyntaxToken,
}
impl AstToken for Minus {
    const KIND: SyntaxKind = SyntaxKind::MINUS;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Asterisk {
    syntax: SyntaxToken,
}
impl AstToken for Asterisk {
    const KIND: SyntaxKind = SyntaxKind::ASTERISK;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Slash {
    syntax: SyntaxToken,
}
impl AstToken for Slash {
    const KIND: SyntaxKind = SyntaxKind::SLASH;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Percent {
    syntax: SyntaxToken,
}
impl AstToken for Percent {
    const KIND: SyntaxKind = SyntaxKind::PERCENT;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct EqEq {
    syntax: SyntaxToken,
}
impl AstToken for EqEq {
    const KIND: SyntaxKind = SyntaxKind::EQ_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct GreaterEq {
    syntax: SyntaxToken,
}
impl AstToken for GreaterEq {
    const KIND: SyntaxKind = SyntaxKind::GREATER_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Greater {
    syntax: SyntaxToken,
}
impl AstToken for Greater {
    const KIND: SyntaxKind = SyntaxKind::GREATER;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct LessEq {
    syntax: SyntaxToken,
}
impl AstToken for LessEq {
    const KIND: SyntaxKind = SyntaxKind::LESS_EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Less {
    syntax: SyntaxToken,
}
impl AstToken for Less {
    const KIND: SyntaxKind = SyntaxKind::LESS;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Eq {
    syntax: SyntaxToken,
}
impl AstToken for Eq {
    const KIND: SyntaxKind = SyntaxKind::EQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct NotEq {
    syntax: SyntaxToken,
}
impl AstToken for NotEq {
    const KIND: SyntaxKind = SyntaxKind::NEQ;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct LParen {
    syntax: SyntaxToken,
}
impl AstToken for LParen {
    const KIND: SyntaxKind = SyntaxKind::L_PAREN;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct RParen {
    syntax: SyntaxToken,
}
impl AstToken for RParen {
    const KIND: SyntaxKind = SyntaxKind::R_PAREN;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct LBracket {
    syntax: SyntaxToken,
}
impl AstToken for LBracket {
    const KIND: SyntaxKind = SyntaxKind::L_BRACKET;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct RBracket {
    syntax: SyntaxToken,
}
impl AstToken for RBracket {
    const KIND: SyntaxKind = SyntaxKind::R_BRACKET;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct LBrace {
    syntax: SyntaxToken,
}
impl AstToken for LBrace {
    const KIND: SyntaxKind = SyntaxKind::L_BRACE;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct RBrace {
    syntax: SyntaxToken,
}
impl AstToken for RBrace {
    const KIND: SyntaxKind = SyntaxKind::R_BRACE;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Dot {
    syntax: SyntaxToken,
}
impl AstToken for Dot {
    const KIND: SyntaxKind = SyntaxKind::DOT;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Colon {
    syntax: SyntaxToken,
}
impl AstToken for Colon {
    const KIND: SyntaxKind = SyntaxKind::COLON;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct QMark {
    syntax: SyntaxToken,
}
impl AstToken for QMark {
    const KIND: SyntaxKind = SyntaxKind::QMARK;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Semicolon {
    syntax: SyntaxToken,
}
impl AstToken for Semicolon {
    const KIND: SyntaxKind = SyntaxKind::SEMICOLON;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Comma {
    syntax: SyntaxToken,
}
impl AstToken for Comma {
    const KIND: SyntaxKind = SyntaxKind::COMMA;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct AndKw {
    syntax: SyntaxToken,
}
impl AstToken for AndKw {
    const KIND: SyntaxKind = SyntaxKind::AND_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct OrKw {
    syntax: SyntaxToken,
}
impl AstToken for OrKw {
    const KIND: SyntaxKind = SyntaxKind::OR_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct NotKw {
    syntax: SyntaxToken,
}
impl AstToken for NotKw {
    const KIND: SyntaxKind = SyntaxKind::NOT_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct InKw {
    syntax: SyntaxToken,
}
impl AstToken for InKw {
    const KIND: SyntaxKind = SyntaxKind::IN_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct LetKw {
    syntax: SyntaxToken,
}
impl AstToken for LetKw {
    const KIND: SyntaxKind = SyntaxKind::LET_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct IfKw {
    syntax: SyntaxToken,
}
impl AstToken for IfKw {
    const KIND: SyntaxKind = SyntaxKind::IF_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct ElseKw {
    syntax: SyntaxToken,
}
impl AstToken for ElseKw {
    const KIND: SyntaxKind = SyntaxKind::ELSE_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct ForeachKw {
    syntax: SyntaxToken,
}
impl AstToken for ForeachKw {
    const KIND: SyntaxKind = SyntaxKind::FOREACH_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct ContinueKw {
    syntax: SyntaxToken,
}
impl AstToken for ContinueKw {
    const KIND: SyntaxKind = SyntaxKind::CONTINUE_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct BreakKw {
    syntax: SyntaxToken,
}
impl AstToken for BreakKw {
    const KIND: SyntaxKind = SyntaxKind::BREAK_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct ReturnKw {
    syntax: SyntaxToken,
}
impl AstToken for ReturnKw {
    const KIND: SyntaxKind = SyntaxKind::RETURN_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct TrueKw {
    syntax: SyntaxToken,
}
impl AstToken for TrueKw {
    const KIND: SyntaxKind = SyntaxKind::TRUE_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct FalseKw {
    syntax: SyntaxToken,
}
impl AstToken for FalseKw {
    const KIND: SyntaxKind = SyntaxKind::FALSE_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct FnKw {
    syntax: SyntaxToken,
}
impl AstToken for FnKw {
    const KIND: SyntaxKind = SyntaxKind::FN_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct StructKw {
    syntax: SyntaxToken,
}
impl AstToken for StructKw {
    const KIND: SyntaxKind = SyntaxKind::STRUCT_KW;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Newline {
    syntax: SyntaxToken,
}
impl AstToken for Newline {
    const KIND: SyntaxKind = SyntaxKind::NEWLINE;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Id {
    syntax: SyntaxToken,
}
impl AstToken for Id {
    const KIND: SyntaxKind = SyntaxKind::ID;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct NumLit {
    syntax: SyntaxToken,
}
impl AstToken for NumLit {
    const KIND: SyntaxKind = SyntaxKind::NUM;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Str {
    syntax: SyntaxToken,
}
impl AstToken for Str {
    const KIND: SyntaxKind = SyntaxKind::STRING;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct MultilineStr {
    syntax: SyntaxToken,
}
impl AstToken for MultilineStr {
    const KIND: SyntaxKind = SyntaxKind::MULTILINE_STRING;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct SingleLineComment {
    syntax: SyntaxToken,
}
impl AstToken for SingleLineComment {
    const KIND: SyntaxKind = SyntaxKind::SINGLE_LINE_COMMENT;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct BlockComment {
    syntax: SyntaxToken,
}
impl AstToken for BlockComment {
    const KIND: SyntaxKind = SyntaxKind::BLOCK_COMMENT;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Whitespace {
    syntax: SyntaxToken,
}
impl AstToken for Whitespace {
    const KIND: SyntaxKind = SyntaxKind::WHITESPACE;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxToken) -> Self {
        Self { syntax }
    }
    fn get_text(&self) -> &str {
        self.syntax.text()
    }
}
#[derive(Debug, Clone)]
pub struct Expr {
    syntax: SyntaxNode,
}
impl AstNode for Expr {
    const KIND: SyntaxKind = SyntaxKind::Expr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Expr {}
#[derive(Debug, Clone)]
pub struct ExprBlock {
    syntax: SyntaxNode,
}
impl AstNode for ExprBlock {
    const KIND: SyntaxKind = SyntaxKind::ExprBlock;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ExprBlock {}
#[derive(Debug, Clone)]
pub struct KExpr {
    syntax: SyntaxNode,
}
impl AstNode for KExpr {
    const KIND: SyntaxKind = SyntaxKind::KExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl KExpr {
    pub fn get_id(&self) -> Id {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_equal(&self) -> Eq {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expr(&self) -> Expr {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct ArrayLitExpr {
    syntax: SyntaxNode,
}
impl AstNode for ArrayLitExpr {
    const KIND: SyntaxKind = SyntaxKind::ArrayLitExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ArrayLitExpr {
    pub fn get_lbracket(&self) -> LBracket {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expr_iter(&self) -> impl Iterator<Item = Expr> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rbracket(&self) -> RBracket {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct MapLitExpr {
    syntax: SyntaxNode,
}
impl AstNode for MapLitExpr {
    const KIND: SyntaxKind = SyntaxKind::MapLitExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl MapLitExpr {
    pub fn get_lbrace(&self) -> LBrace {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expr_iter(&self) -> impl Iterator<Item = KExpr> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rbrace(&self) -> RBrace {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct StrLit {
    syntax: SyntaxNode,
}
impl AstNode for StrLit {
    const KIND: SyntaxKind = SyntaxKind::StrLit;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StrLit {
    pub fn get_single_line_string_opt(&self) -> Option<Str> {
        super::get_opt_tok(&self.syntax)
    }
    pub fn get_multiline_string_opt(&self) -> Option<MultilineStr> {
        super::get_opt_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct PrimaryExpr {
    syntax: SyntaxNode,
}
impl AstNode for PrimaryExpr {
    const KIND: SyntaxKind = SyntaxKind::PrimaryExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl PrimaryExpr {}
#[derive(Debug, Clone)]
pub struct PrefixUnaryOpExpr {
    syntax: SyntaxNode,
}
impl AstNode for PrefixUnaryOpExpr {
    const KIND: SyntaxKind = SyntaxKind::PrefixUnaryOpExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl PrefixUnaryOpExpr {
    pub fn get_expr(&self) -> Expr {
        super::get_last(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct InfixBinaryOpExpr {
    syntax: SyntaxNode,
}
impl AstNode for InfixBinaryOpExpr {
    const KIND: SyntaxKind = SyntaxKind::InfixBinOpExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl InfixBinaryOpExpr {
    pub fn get_left_operand(&self) -> Expr {
        super::get_first(&self.syntax)
    }
    pub fn get_right_operand(&self) -> Expr {
        super::get_last(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct FnCallExpr {
    syntax: SyntaxNode,
}
impl AstNode for FnCallExpr {
    const KIND: SyntaxKind = SyntaxKind::FnCallExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnCallExpr {
    pub fn get_fn(&self) -> Expr {
        super::get_first(&self.syntax)
    }
    pub fn get_args(&self) -> FnCallArgsList {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct FnCallArgsList {
    syntax: SyntaxNode,
}
impl AstNode for FnCallArgsList {
    const KIND: SyntaxKind = SyntaxKind::FnCallArgsList;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnCallArgsList {
    pub fn get_lparen(&self) -> LParen {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_args_iter(&self) -> impl Iterator<Item = FArg> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rparen(&self) -> RParen {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct FArg {
    syntax: SyntaxNode,
}
impl AstNode for FArg {
    const KIND: SyntaxKind = SyntaxKind::FArg;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FArg {
    pub fn get_as_expr_opt(&self) -> Option<Expr> {
        super::get_opt(&self.syntax)
    }
    pub fn get_as_kexpr_opt(&self) -> Option<KExpr> {
        super::get_opt(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct TupleExpr {
    syntax: SyntaxNode,
}
impl AstNode for TupleExpr {
    const KIND: SyntaxKind = SyntaxKind::TupleExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl TupleExpr {
    pub fn get_lparen(&self) -> LParen {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expr_iter(&self) -> impl Iterator<Item = Expr> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rparen(&self) -> RParen {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct BoolLit {
    syntax: SyntaxNode,
}
impl AstNode for BoolLit {
    const KIND: SyntaxKind = SyntaxKind::BoolLit;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BoolLit {
    pub fn get_true_opt(&self) -> Option<TrueKw> {
        super::get_opt_tok(&self.syntax)
    }
    pub fn get_false_opt(&self) -> Option<FalseKw> {
        super::get_opt_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct IndexExpr {
    syntax: SyntaxNode,
}
impl AstNode for IndexExpr {
    const KIND: SyntaxKind = SyntaxKind::IndexExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl IndexExpr {
    pub fn get_base(&self) -> Expr {
        super::get_single(&self.syntax)
    }
    pub fn get_brackets_expr(&self) -> IndexExprBrackets {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct IndexExprBrackets {
    syntax: SyntaxNode,
}
impl AstNode for IndexExprBrackets {
    const KIND: SyntaxKind = SyntaxKind::IndexExprBrackets;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl IndexExprBrackets {
    pub fn get_lbracket(&self) -> LBracket {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expr(&self) -> Expr {
        super::get_single(&self.syntax)
    }
    pub fn get_rbracket(&self) -> RBracket {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Assignment {
    syntax: SyntaxNode,
}
impl AstNode for Assignment {
    const KIND: SyntaxKind = SyntaxKind::Assignment;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Assignment {
    pub fn get_target_expr(&self) -> Expr {
        super::get_first(&self.syntax)
    }
    pub fn get_value(&self) -> Expr {
        super::get_last(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Declaration {
    syntax: SyntaxNode,
}
impl AstNode for Declaration {
    const KIND: SyntaxKind = SyntaxKind::Declaration;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Declaration {
    pub fn get_let(&self) -> LetKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_name(&self) -> Id {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_eq(&self) -> Eq {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_value(&self) -> Expr {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Conditional {
    syntax: SyntaxNode,
}
impl AstNode for Conditional {
    const KIND: SyntaxKind = SyntaxKind::Conditional;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Conditional {
    pub fn get_branches_iter(&self) -> impl Iterator<Item = ConditionalBranch> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_else_kw(&self) -> ElseKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_else_block(&self) -> ExprBlock {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Foreach {
    syntax: SyntaxNode,
}
impl AstNode for Foreach {
    const KIND: SyntaxKind = SyntaxKind::Foreach;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Foreach {
    pub fn get_foreach_kw(&self) -> ForeachKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_for_in_expr(&self) -> ForInExpr {
        super::get_single(&self.syntax)
    }
    pub fn get_block(&self) -> ExprBlock {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct ForInExpr {
    syntax: SyntaxNode,
}
impl AstNode for ForInExpr {
    const KIND: SyntaxKind = SyntaxKind::ForInExpr;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ForInExpr {
    pub fn get_binding(&self) -> Expr {
        super::get_first(&self.syntax)
    }
    pub fn get_in_kw(&self) -> InKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_iterator(&self) -> Expr {
        super::get_last(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct ControlStatement {
    syntax: SyntaxNode,
}
impl AstNode for ControlStatement {
    const KIND: SyntaxKind = SyntaxKind::ControlStatement;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ControlStatement {
    pub fn get_continue_kw_opt(&self) -> Option<ContinueKw> {
        super::get_opt_tok(&self.syntax)
    }
    pub fn get_break_kw_opt(&self) -> Option<BreakKw> {
        super::get_opt_tok(&self.syntax)
    }
    pub fn get_return_kw_opt(&self) -> Option<ReturnKw> {
        super::get_opt_tok(&self.syntax)
    }
    pub fn get_expr_opt(&self) -> Option<Expr> {
        super::get_opt(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct ExprStatement {
    syntax: SyntaxNode,
}
impl AstNode for ExprStatement {
    const KIND: SyntaxKind = SyntaxKind::ExprStatement;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ExprStatement {
    pub fn get_expr(&self) -> Expr {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Tuple {
    syntax: SyntaxNode,
}
impl AstNode for Tuple {
    const KIND: SyntaxKind = SyntaxKind::Tuple;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Tuple {
    pub fn get_lparen(&self) -> LParen {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_expression_iter(&self) -> impl Iterator<Item = Expr> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rparen(&self) -> RParen {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct ConditionalBranch {
    syntax: SyntaxNode,
}
impl AstNode for ConditionalBranch {
    const KIND: SyntaxKind = SyntaxKind::ConditionalBranch;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ConditionalBranch {
    pub fn get_if_kw(&self) -> IfKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_condition(&self) -> Expr {
        super::get_single(&self.syntax)
    }
    pub fn get_block(&self) -> ExprBlock {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Statement {
    syntax: SyntaxNode,
}
impl AstNode for Statement {
    const KIND: SyntaxKind = SyntaxKind::Statement;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Statement {
    pub fn get_expr_statement_opt(&self) -> Option<ExprStatement> {
        super::get_opt(&self.syntax)
    }
    pub fn get_assignment_statement_opt(&self) -> Option<Assignment> {
        super::get_opt(&self.syntax)
    }
    pub fn get_declaration_statement_opt(&self) -> Option<Declaration> {
        super::get_opt(&self.syntax)
    }
    pub fn get_conditional_statement_opt(&self) -> Option<Conditional> {
        super::get_opt(&self.syntax)
    }
    pub fn get_foreach_statement_opt(&self) -> Option<Foreach> {
        super::get_opt(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct StructDecl {
    syntax: SyntaxNode,
}
impl AstNode for StructDecl {
    const KIND: SyntaxKind = SyntaxKind::StructDecl;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructDecl {
    pub fn get_struct_kw(&self) -> StructKw {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_name(&self) -> Id {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_field_list(&self) -> StructFieldList {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct StructFieldList {
    syntax: SyntaxNode,
}
impl AstNode for StructFieldList {
    const KIND: SyntaxKind = SyntaxKind::StructFieldList;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructFieldList {
    pub fn get_lbrace(&self) -> LBrace {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_fields_iter(&self) -> impl Iterator<Item = StructField> {
        super::get_multiple(&self.syntax)
    }
    pub fn get_rbrace(&self) -> RBrace {
        super::get_single_tok(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct StructField {
    syntax: SyntaxNode,
}
impl AstNode for StructField {
    const KIND: SyntaxKind = SyntaxKind::StructField;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructField {
    pub fn get_name(&self) -> Id {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_colon(&self) -> Colon {
        super::get_single_tok(&self.syntax)
    }
    pub fn get_type(&self) -> TypeRef {
        super::get_single(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct TypeRef {
    syntax: SyntaxNode,
}
impl AstNode for TypeRef {
    const KIND: SyntaxKind = SyntaxKind::TypeRef;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl TypeRef {}
#[derive(Debug, Clone)]
pub struct TypeRefGenerics {
    syntax: SyntaxNode,
}
impl AstNode for TypeRefGenerics {
    const KIND: SyntaxKind = SyntaxKind::TypeRefGenerics;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl TypeRefGenerics {}
#[derive(Debug, Clone)]
pub struct LangItem {
    syntax: SyntaxNode,
}
impl AstNode for LangItem {
    const KIND: SyntaxKind = SyntaxKind::LangItem;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl LangItem {
    pub fn get_statement_opt(&self) -> Option<Statement> {
        super::get_opt(&self.syntax)
    }
    pub fn get_struct_decl_opt(&self) -> Option<StructDecl> {
        super::get_opt(&self.syntax)
    }
}
#[derive(Debug, Clone)]
pub struct Root {
    syntax: SyntaxNode,
}
impl AstNode for Root {
    const KIND: SyntaxKind = SyntaxKind::ROOT;
    #[allow(unsafe_code)]
    unsafe fn new(syntax: SyntaxNode) -> Self {
        Self { syntax }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl Root {
    pub fn get_lang_items_iter(&self) -> impl Iterator<Item = LangItem> {
        super::get_multiple(&self.syntax)
    }
}

use crate::{
	grammar::{
		lexer,
		lexer::TokLoc,
		ast::*,
	},
};

grammar;

pub Program = <Statement*>;
Statement: AstStatement = {
    <MethodCall> ";" => AstStatement::MethodCall(<>),
	<FuncCall> ";" => AstStatement::FuncCall(<>),
	<Assignment> ";" => AstStatement::Assignment(<>),
	<Declaration> ";" => AstStatement::Declaration(<>),
	<ConditionalStatement> => AstStatement::Conditional(<>),
	//<ControlStatement> => AstStatement::ControlStatement(<>),
	<RepetitiveStatement> => AstStatement::Repetitive(<>),
};

FuncCall: AstFuncCall = {
	<name:IdExpression> "(" <args:FuncArgs> <end:")"> => AstFuncCall::new(name, args, end.get_end())
};

FuncArgs:AstFuncCallArgs = {
	<pos_args:PositionalFuncArgs> "," <named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new(pos_args,named_args),
	<pos_args:PositionalFuncArgs> ","? => AstFuncCallArgs::new_only_positional(pos_args),
	<named_args:NamedFuncArgs> ","? => AstFuncCallArgs::new_only_named(named_args),
	() => AstFuncCallArgs::empty(),
};

#[inline]
PositionalFuncArgs: Vec<AstPositionalArg> = {
	<arg1:PositionalFuncArg> <rest:("," <PositionalFuncArg>)*> => {let mut v = vec![arg1]; v.extend(rest); v.into_iter().map(|box_ : Box<Expr>| AstPositionalArg::from(box_)).collect()},
};

PositionalFuncArg = { Expr };

#[inline]
NamedFuncArgs: Vec<AstNamedExpr> = {
	<arg1:NamedExpr> <rest:("," <NamedExpr>)*> => {let mut v = vec![arg1]; v.extend(rest); v}
};

NamedExpr: AstNamedExpr = {
	<name:IdExpression> ":" <value:Expr> => AstNamedExpr::from((name, value))
};

AddExpr: Box<Expr> = { // (1)
    AddExpr AddOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

AddOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

CheckExpr: Box<Expr> = {
	AddExpr RelOp AddExpr => Box::new(Expr::Op(<>)),
	AddExpr,
};

UnaryNot: UnaryOpcode = {
	"not" => UnaryOpcode::Not(<>),
};

AndConditionalExpr: Box<Expr> = {
	AndConditionalExpr AndOp CheckExpr => Box::new(Expr::Op(<>)),
	CheckExpr,
};

AndOp: Opcode = {
	"and" => Opcode::And,
};

OrConditionalExpr: Box<Expr> = {
	OrConditionalExpr OrOp AndConditionalExpr => Box::new(Expr::Op(<>)),
	AndConditionalExpr,
};

OrOp: Opcode = {
	"or" => Opcode::Or,
};

RelOp: Opcode = {
	"==" => Opcode::Equal,
	">" => Opcode::G,
	"<" => Opcode::L,
	">=" => Opcode::GE,
	"<=" => Opcode::LE,
	"!=" => Opcode::NE,
	"in" => Opcode::In,
	"not" "in" => Opcode::NotIn,
};

Expr: Box<Expr> = {
	OrConditionalExpr,
};

Factor: Box<Expr> = {
    Factor FactorOp TermWithUnaryOps => Box::new(Expr::Op(<>)),
    TermWithUnaryOps,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

TermWithUnaryOps: Box<Expr> = {
	UnaryNeg Term => Box::new(Expr::UnaryOp(<>)),
	UnaryNot Term => Box::new(Expr::UnaryOp(<>)),
	Term,
};

Term: Box<Expr> = {
    "num" => Box::new(Expr::Atom(Atom::Number(<>))),
    "str" => Box::new(Expr::Atom(Atom::Str(<>))),
    "bool_lit" => Box::new(Expr::Atom(Atom::Bool(<>))),
    <begin:"("> <value:Expr> <end:")"> => Box::new(Expr::ParenExpr(begin.get_begin(), value, end.get_end())),
    <MethodCall> => Box::new(Expr::MethodCall(<>)),
    <PropertyAccess> => Box::new(Expr::PropertyAccess(<>)),
    <FuncCall> => Box::new(Expr::FuncCall(<>)),
    <IdExpression> => Box::new(Expr::Atom(Atom::Id(<>))),
    <base:Term> <br_open:"["> <ind:Expr> <br_close:"]"> => Box::new(Expr::Indexed{base, bracket_open: br_open, index: ind, bracket_close: br_close}),
    ArrayLit, MapLit, Ternary,
};

Ternary: Box<Expr> = {
    "(" Expr "?" Expr ":" Expr ")" => Box::new(Expr::Ternary(<>)),
};

UnaryNeg: UnaryOpcode = {
	"-" => UnaryOpcode::Neg(<>),
};

PropertyAccess: AstPropertyAccess = {
    <t:Term> "." <prop_name:IdExpression> => AstPropertyAccess::new(t, prop_name)
};

MethodCall: AstMethodCall = {
	<property_access:PropertyAccess> "(" <args:FuncArgs> <end:")"> => AstMethodCall::new(property_access, args, end.get_end()),
};

Declaration: AstDeclaration = {
	<begin: "let"> <name: IdExpression> "=" <value: Expr> => AstDeclaration::new(name, value, begin)
};

Assignment: AstAssignment = {
	<bind_name: Expr> <op: AtrOp> <val: Expr> => AstAssignment::new(bind_name, op, val),
};

AtrOp: AstAtrOp = {
	"=" => AstAtrOp::Atr,
	"+=" => AstAtrOp::AddAtr,
	"-=" => AstAtrOp::SubAtr,
	"*=" => AstAtrOp::MulAtr,
	"/=" => AstAtrOp::DivAtr,
	"%=" => AstAtrOp::ModAtr,
};

ArrayLit: Box<Expr> = {
	<b:"{"> <arg1:Expr> <rest:("," <Expr>)*> ","? <e:"}"> => Box::new(Expr::Atom(Atom::ArrayLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(b.get_begin(), e.get_end())))))
};

MapLit: Box<Expr> = {
	<b:"{"> <arg1:NamedExpr> <rest:("," <NamedExpr>)*>  ","?  <e:"}"> => Box::new(Expr::Atom(Atom::MapLit(({let mut v = vec![arg1]; v.extend(rest); v}, TokLoc::new(b.get_begin(), e.get_end())))))
};

#[inline]
ConditionalStatement: AstConditionalStatement = {
	<initial: If> <others: ElseIf*> <else_statement: Else?> => AstConditionalStatement::new(initial, others, else_statement),
};

If: AstIf = {
	<"if"> <Expr> "{" <Statement+> <"}"> => AstIf::new(<>),
};

ElseIf: AstElseIf = {
	<"else"> <If> => AstElseIf::new(<>),
};

Else: AstElse = {
	<"else"> "{" <Statement+> <"}"> => AstElse::new(<>),
};

RepetitiveStatement: AstRepetitiveStatement = {
    <foreach_tok: "foreach"> <for_in_expr: ForInExpr> "{" <statement:Statement*> <end:"}"> => AstRepetitiveStatement::new(<>),
};

ForInExpr: AstForInExpr = {
    "id" "in" Expr => AstForInExpr::new(<>),
};

ControlStatement: AstControlStatement = {
	"break" => AstControlStatement::Break(<>),
	"continue" => AstControlStatement::Continue(<>),
};

IdExpression = { "id" };

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "+=" => lexer::Tok::AddEq(<TokLoc>),
        "-=" => lexer::Tok::SubEq(<TokLoc>),
        "*=" => lexer::Tok::MulEq(<TokLoc>),
        "/=" => lexer::Tok::DivEq(<TokLoc>),
        "%=" => lexer::Tok::ModEq(<TokLoc>),
        "=" => lexer::Tok::Eq(<TokLoc>),
        "+" => lexer::Tok::Add(<TokLoc>),
        "-" => lexer::Tok::Sub(<TokLoc>),
        "*" => lexer::Tok::Mul(<TokLoc>),
        "/" => lexer::Tok::Div(<TokLoc>),
        "%" => lexer::Tok::Mod(<TokLoc>),
        "(" => lexer::Tok::POPEN(<TokLoc>),
        ")" => lexer::Tok::PCLOSE(<TokLoc>),
        "[" => lexer::Tok::BracketOpen(<TokLoc>),
        "]" => lexer::Tok::BracketClose(<TokLoc>),
        "{" => lexer::Tok::BOPEN(<TokLoc>),
        "}" => lexer::Tok::BCLOSE(<TokLoc>),
        "and" => lexer::Tok::And(<TokLoc>),
        "or" => lexer::Tok::Or(<TokLoc>),
        "==" => lexer::Tok::Equal(<TokLoc>),
        ">=" => lexer::Tok::GE(<TokLoc>),
        "<=" => lexer::Tok::LE(<TokLoc>),
        ">" => lexer::Tok::G(<TokLoc>),
        "<" => lexer::Tok::L(<TokLoc>),
        "!=" => lexer::Tok::NE(<TokLoc>),

        "in" => lexer::Tok::In(<TokLoc>),
        "not" => lexer::Tok::Not(<TokLoc>),

        "let" => lexer::Tok::Let(<TokLoc>),
        "if" => lexer::Tok::If(<TokLoc>),
        "else" => lexer::Tok::Else(<TokLoc>),
        "continue" => lexer::Tok::Continue(<TokLoc>),
        "break" => lexer::Tok::Break(<TokLoc>),

		"bool_lit" => lexer::Tok::Bool(<bool>, <TokLoc>),
        "num" => lexer::Tok::Number(<i32>, <TokLoc>),
        "id" => lexer::Tok::Identifier(<String>, <TokLoc>),
        "str" => lexer::Tok::Str(<String>, <TokLoc>),
        "foreach" => lexer::Tok::Foreach(<TokLoc>),

        ";" => lexer::Tok::Semicolon(<TokLoc>),
        ":" => lexer::Tok::Colon(<TokLoc>),
        "?" => lexer::Tok::QMark(<TokLoc>),
        "," => lexer::Tok::Comma(<TokLoc>),
        "." => lexer::Tok::Dot(<TokLoc>),
    }
}